---
title : Algorithm - 시간 복잡도(Time Complexity)
date : 2023-09-16 17:25:43 +09:00
categories : [Study,Algorithm]
tags : [Algorithm]
---

## 빅 오 표기법이 필요한 이유
<hr>

- `알고리즘 수행에 필요한 단계 수`가 알고리즘의 효율성을 결정하는 주된 요인이다.
- 단순히 알고리즘을 "몇 단계의 알고리즘"이라고 표시할 수는 없다.
- `단계 수라는 것을 하나의 수로 확정지을 수 없기 때문이다.`
    - 예로 [선형 검색](#선형-검색--이진-검색)에는 배열의 원소 개수 만큼 단계 수가 필요하다. 그래서 원소가 4개일 때는 4단계, 100개일 때는 100단계가 필요하므로 그때 마다 달라지는 것이다.
- 이러한 선형 검색의 효율성을 `배열에 N개의 원소가 있을 때 N단계가 필요하다`라고 표현하는 것이 몇 단계로 정량화 하는 것보다 훨씬 효과적이다.
- 컴퓨터 과학자는 시간 복잡도를 쉽게 소통할 목적으로 자료 구조와 알고리즘의 효율성을 간결하고 일관된 언어로 설명하기 위해 수학적 개념을 차용했다. 이러한 개념의 형식화한 표현을 `빅 오 표기법`이라고 부른다.

<br>

## 빅 오의 본질
<hr>

1. ### **데이터 원소 N개에 대한 알고리즘의 단계 수**
   <hr>
   - O(N)은 알고리즘에 N 단계가 필요하다는 것을 의미.
   - 빅 오는 데이터 원소가 N개일 때 알고리즘에 몇 단계가 필요한가에 대한 답이다. 데이터 원소 N개에 대한 알고리즘의 단계 수를 나타낸다. <br><br>
    
2. ### **데이터가 늘어날 때 단계 수가 어떻게 증가하는가**
    <hr>
   - `O(3) == O(100) == O(1)` <br>
     - 예로 데이터가 몇 개든 항상 3단계가 걸리는 알고리즘을 가정하자. <br>
    즉 원소가 N개일 때 알고리즘에 항상 3단계가 필요하다. <br>
    이를 빅 오로 어떻게 표현할까? <br>
    O(3)일까? 아니다. O(1)이다. <br>
    이유는 빅 오가 알고리즘에 필요한 단계 수를 알려주는 것 말고도 한가지 더 역할을 한다는 것에 있다. 
     - 빅 오는 단순히 알고리즘에 필요한 단계 수 뿐만 아니라 **데이터가 늘어날 때 알고리즘의 단계 수가 어떻게 증가하는지, 성능이 어떻게 바뀌는지도 설명한다.**
     - O(1)과 O(3) 두 알고리즘 모두 데이터 증가에 영향을 받지 않는다. <br> 즉 단계 수가 변하지 않는 유형이므로 본질적으로 같은 알고리즘 유형이다. <br> N이 얼마든 항상 상수 단계만 필요하다. 그래서 O(1) 알고리즘을 상수시간 constant time을 갖는 알고리즘이라고도 표현한다. <br> 둘 다 데이터에 관계없이 단계 수가 일정한 알고리즘이므로 둘을 구분할 필요가 없다. <br><br>
   - `O(1)과 O(N)에서 데이터 변화가 미치는 영향`
     - O(1)이 데이터 증가 또는 감소에 영향을 받지 않는 반면 O(N) 알고리즘은 데이터 증가가 성능에 영향을 미친다. 데이터가 늘어날 때 정확히 그 데이터에 비례해 단계 수가 증가하는 알고리즘 유형이다. 알고리즘의 효율성과 데이터가 비례 관례이다.
     - 데이터가 증가할 때 단계 수가 정확히 어떻게 증가하는지 설명한다. <br><br>
   - `O(1)과 O(N) 그래프`
   - ![O1ON](https://github.com/no2j/no2j.github.io/assets/106552182/77d47ad6-6647-4578-a0c6-9b60e1cb64f3)
     - O(N)은 완벽한 대각선을 그린다. 데이터가 하나씩 추가될 때마다 알고리즘이 한 단계씩 더 걸리기 때문이다. 따라서 데이터가 많아질수록 알고리즘에 필요한 단계 수도 늘어난다.
     - O(1)은 완벽한 수평선을 그린다. 데이터의 증가나 감소에 영향 받지 않고 단계 수가 일정하다. <br><br>
   - `O(1) 알고리즘이 항상 O(N)보다 빠를까?`
   - ![O1ON2](https://github.com/no2j/no2j.github.io/assets/106552182/acf9b52e-3759-45a5-af94-b7f033bb73ef)
     - 원소가 100개 이하인 데이터 셋에서는 100단계가 걸리는 O(1)알고리즘보다 O(N)알고리즘이 단계 수가 더 적다.
     - 두 선이 교차하는 원소가 정확히 100개인 지점에서는 두 알고리즘의 단계 수가 동일하게 100단계이다.
     - 100보다 큰 모든 배열에서는 O(N) 알고리즘이 100단계 O(1) 알고리즘보다 항상 더 많은 단계가 걸린다.
     - **변화가 생기는 일정량의 데이터가 있을 것이고 O(N)은 그 순간부터 무한대까지 더 많은 단계가 걸리므로 O(1)알고리즘에 실제로 몇 단계가 걸리든 O(N)이 전반적으로 O(1)보다 덜 효율적이라 볼 수 있다.** <br>
      
3. ### **최악의 시나리오**
<hr>

   - `빅 오 표기법은 일반적으로 최악의 시나리오를 의미한다.`
     - 예로 선형 검색이 항상 O(N)은 아니다.
     - 검색값이 배열의 맨 처음에 있는 최선의 시나리오에서는 O(1)이고
     - 검색값이 배열의 맨 끝에 있는 최악의 시나리오에서는 O(N)이다.
     - `최악의 시나리오에서 알고리즘이 얼마나 비효율적인지 정확히 알면 최악을 대비함과 동시에 알고리즘의 선택에 중요한 영향을 미칠 수 있다.` <br>

<br>

## O(N)
<hr>

 - `O(N)`
   - 데이터 원소가 N개일 때 N단계가 걸리는 알고리즘이다.
   - 데이터가 늘어날 때 정확히 그 데이터에 비례해 단계 수가 증가하는 알고리즘이다.
   - "빅 오 N", "차수 N","오 N"이라고 부른다. <br>

<br>

## O(1)
<hr>

 - `O(1)`
   - 데이터 원소가 N개와 상관없이 항상 일정한 상수 갯수의 단계 수만 걸리는 알고리즘이다.
   - 데이터 증가에 영향을 받지 않는 알고리즘이다.
   - N이 얼마든 항상 상수 단계만 필요하다. 그래서 O(1) 알고리즘을 상수시간 constant time을 갖는 알고리즘이라도 표현한다.
   - "오 1"이라고 부른다. <br>

<br>

## 로그 log
<hr>

 - `로그 log`
   - 로그는 로가리즘 logarithm의 줄임말이다.
     - 지수(exponent)와 역(inverse)의 관계이다.
       - log₂8은 2³의 역 converse 관계이다.
       - log₂64는 2⁶의 역이다.
     - 2를 몇번 곱해야 N이 나올까? = log₂N
       - 2를 세 번 곱해야 8이 나오므로 log₂8 = 3이다.
       - 2를 여섯 번 곱해야 8이 나오므로 log₂64 = 6이다.
     - 1이 될 때까지 N을 2로 몇번 곱해야 할까? = log₂N
       - 8이 1이 될 때까지 2를 세번 나눠야 하므로 log₂8 = 3이다.
       - 64가 1이 될 때까지 2를 여섯 번 나눠야 하므로 log₂64 = 6이다. <br> <br>
 - `O(logN)` : 로그시간
   - O(logN) == O(log₂N)
     - 컴퓨터 과학에서 O(logN)은 O(log₂N)을 줄여 부르는 말이다.
     - O(logN)은 데이터 원소가 N개 있을 때 알고리즘에 log₂단계가 걸린다.
     - 원소가 8개면 log₂8 = 3이므로 이 알고리즘은 3단계가 걸린다.
   - 이진 검색을 빅 오 표기법의 관점에서 어떻게 설명할까?
     - 이진 검색이 정확히 O(logN) 알고리즘 방식으로 동작한다.
     - 데이터가 커질수록 단계 수가 늘어나므로 이진 검색은 O(1)이라 표현할 수 없다.
     - 검색하고 있는 배열의 원소 수보다 단계 수가 훨씬 적으므로 O(N)이라 표현할 수도 없다.
     - `이진 검색은 O(1)과 O(N)사이에 있는데 이것을 빅 오로 O(logN)으로 나타낸다.`
     - "오 로그 앤"이라고 부른다.

<br>

## O(logN)
<hr>

  - O(logN) : 오 로그 N
    - 로그시간 log time의 시간 복잡도
    - 데이터 원소가 N개 있을 때 알고리즘에 log₂단계가 걸린다.
    - 데이터가 두 배로 증가할 때마다 한 단계씩 늘어나는 알고리즘

<br>

## O(1) & O(N) & O(logN) 그래프
<hr>

![효율](https://github.com/no2j/no2j.github.io/assets/106552182/3def6a29-2acc-48f6-9eab-67284c67df78)

- O(1) > O(logN) > O(N) 순으로 가장 효율적이다.
- O(logN)은 조금씩 증가하는 곡선을 그리고 있는데 O(1)보다는 덜 효율적이지만 O(N)보다는 훨씬 효율적이다.

<br>

## 선형 검색 & 이진 검색
<hr>

![img](https://github.com/no2j/no2j.github.io/assets/106552182/a093cfc6-c022-4825-a86c-1dc5798ca9d7)

<br>

### 선형 검색 (Linear search)
<hr>

`7개의 데이터 중 선형 검색으로 4 찾기` <br>
<img width="441" alt="선형검색" src="https://github.com/no2j/no2j.github.io/assets/106552182/c1582ade-3f56-4541-b7ad-23e7233de36b">
- 선형 검색 알고리즘은 여러 개의 데이터가 들어있는 리스트에서 찾고자 하는 값이 나올 때 까지 처음부터 하나씩 차례대로 검색하는 알고리즘이다.
- 예로 100개의 데이터 중 찾으려는 데이터가 100번째에 있다면 100개의 데이터를 다 확인해봐야 찾을 수 있는 것이다. <br> 데이터 개수가 늘어날수록 시간이 오래걸리게 된다는 단점이 있다.

<br>

### 이진 검색 (binary search)
<hr>

`7개의 데이터 중 이진 검색으로 4 찾기`
<img width="509" alt="이진검색" src="https://github.com/no2j/no2j.github.io/assets/106552182/484059cb-f137-40b3-95fa-6f24b5e4e5d4">

- 이진 검색 알고리즘은 원하는 값을 찾을 때까지 검색할 데이터의 범위를 반씩 줄여가며 찾는 알고리즘이다.
  - 검색 범위를 반으로 나누어 원하는 값이 나올 때까지 계속 검색하는 것이다.
  - 선형 검색과는 다르게 특정 기준에 따라 오름차순 또는 내림차순으로 정렬된 리스트를 입력으로 받는다.
- 예로 "업다운 게임"이라고 생각하면 된다. 1~100이란 범위가 있으면 먼저50을 기준으로 유추하고 더 낮다고 하면 25 더 낮다면 13... 이런 식이다.
- 데이터들 간의 대소관계를 이용하기 때문에 오름차순 또는 내림차순 "정렬"이 되어있어야 이 알고리즘으로 검색을 할 수 있다.

<br>

### 요약
<hr>

- `선형 검색 (linear search)`
  - 배열에서 원하는 값을 찾을 때까지 맨앞부터 스캔하여 순서대로 검색 (최악의 경우 O(N))

<br>

- `이진 검색 (binary search)` 
  - 정렬된 배열에서 원하는 값을 찾을 때까지 범위를 반씩 줄여가며 검색 (최악의 경우 (log2n)+1)